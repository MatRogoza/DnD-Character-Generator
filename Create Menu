import tkinter as tk
from tkinter import ttk
import sqlite3





#list of classes for the class dropdown
class_options = ['Artificier', 'Barbarian', 'Bard', 'Cleric', 'Druid', 'Fighter', 'Monk', 'Paladin', 'Ranger', 'Rogue', 'Sorcerer', 'Warlock', 'Wizard']
#list of class levels for the level dropdown
class_levels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

def center_window(window, width, height): #function to center window
    screen_width = window.winfo_screenwidth()
    screen_height = window.winfo_screenheight()

    x = int((screen_width / 2) - (width / 2))
    y = int((screen_height / 2) - (height / 2))

    window.geometry(f'{width}x{height}+{x}+{y}')

#function to populate the selected classes' features for what level you are
def display_class_features(selected_class, selected_level):
    conn = sqlite3.connect('dnd_character_info.db')
    c = conn.cursor()
    
    class_id = class_options.index(selected_class) + 1

    c.execute('SELECT * FROM features WHERE class_id = ? AND level <= ? ORDER BY level', (class_id, selected_level))
    features = c.fetchall()
    
    text_features_box.delete(1.0, tk.END)

    if features:
        for feature in features:
            # Insert feature into the Text widget
            text_features_box.insert(tk.END, f"Level {feature[3]}: {feature[2]} - {feature[4]}\n\n")
    else:
        text_features_box.insert(tk.END, "No features found for this class at the selected level.\n")


#create the new buttons for the level once class is chosen
def class_level_button(e):
    label_class_level = tk.Label(create_window, text='Level:')
    label_class_level.grid(row=1, column=2, padx=10, pady=10)

    combo_class_level = ttk.Combobox(create_window, values=class_levels, width=2)
    combo_class_level.grid(row=1, column=3, padx=10, pady=10)

    combo_class_level.bind('<<ComboboxSelected>>', lambda e: display_class_features(combo_class.get(), combo_class_level.get()))
    

#Event trigger and label once a class is chosen
def get_class_level(e):
    label_class_name = tk.Label(create_window, text=f"You selected: {combo_class.get()}")
    label_class_name.grid(row=2, column=0, columnspan=2)
    class_level_button(e)
    

    
#function to call the create character menu
def create_menu():
    global create_window
    global text_features_box  # Make the text widget global to access it in other functions

    create_window = tk.Tk()
    create_window.title("Mat's D&D Character Sheet")
    create_window.geometry('1000x600')

    # Labels for the create character menu
    label_name = tk.Label(create_window, text='Character Name:')
    label_class = tk.Label(create_window, text='Class:')

    # Positions of the labels
    label_name.grid(row=0, column=0, padx=10, pady=10)
    label_class.grid(row=1, column=0, padx=10, pady=10)

    # Entry for the Character name
    entry_name = tk.Entry(create_window)
    entry_name.grid(row=0, column=1)

    # Class selection dropdown
    global combo_class
    combo_class = ttk.Combobox(create_window, values=class_options)
    combo_class.grid(row=1, column=1, padx=10, pady=10)

    # Binding the action of selecting a class to then make the level button
    combo_class.bind('<<ComboboxSelected>>', get_class_level)

    # Create a frame to hold the Text widget and scrollbar
    frame_features = tk.Frame(create_window)
    frame_features.grid(row=3, column=0, columnspan=4, padx=10, pady=10)

    # Create a scrollbar for the Text widget
    scrollbar = tk.Scrollbar(frame_features)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    # Create a Text widget to display features
    text_features_box = tk.Text(frame_features, wrap=tk.WORD, height=20, width=80, yscrollcommand=scrollbar.set)
    text_features_box.pack(side=tk.LEFT, fill=tk.BOTH)

    # Configure the scrollbar to scroll the Text widget
    scrollbar.config(command=text_features_box.yview)

    center_window(create_window, 1000, 600)
    
#test to see if the db is being connected
def list_all_tables():
    try:
        conn = sqlite3.connect(r'f:\Python\D&D Sheets\dnd_character_info.db')
        c = conn.cursor()

        # Query to list all tables in the database
        c.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = c.fetchall()

        if tables:
            print("Tables in the database:")
            for table in tables:
                print(table[0])
        else:
            print("No tables found in the database.")
            
        conn.close()

    except sqlite3.Error as e:
        print(f"An error occurred: {e}")
